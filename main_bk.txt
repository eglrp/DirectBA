#include "DataStructure.h"
#include "Ultility.h"
#include "MathUlti.h"


#include "ceres/ceres.h"
#include "glog/logging.h"
#include "ceres/cubic_interpolation.h"

using ceres::Grid2D;
using ceres::Grid1D;
using ceres::CubicInterpolator;
using ceres::BiCubicInterpolator;
using ceres::AutoDiffCostFunction;
using ceres::CostFunction;
using ceres::Problem;
using ceres::Solver;
using ceres::Solve;
using ceres::TukeyLoss;
using ceres::SizedCostFunction;
using ceres::CostFunctionToFunctor;

struct DepthImgWarping {
	DepthImgWarping(Point2i uv, double *xycnRef_, uchar *refImg, uchar *nonRefImgs, double *intrinsic, Point2i &imgSize, int nchannels, double isigma, int eleID, int imgID) :
		uv(uv), refImg(refImg), nonRefImgs(nonRefImgs), intrinsic(intrinsic), imgSize(imgSize), nchannels(nchannels), isigma(isigma), eleID(eleID), imgID(imgID)
	{
		for (int ii = 0; ii < 3; ii++)
			xycnRef[ii] = xycnRef_[ii];//xycn changes for every pixel. Pass by ref does not work
	}

	template <typename T>  bool operator()(T const* const* Parameters, T* residuals) const
	{
		//Parametes[0][0]: inverse depth for ref, Parameters[1][0..5]: poses for ref, Parameters[2][0..5]: poses for non-ref, Parameters[3][0..1]: photometric compenstation
		T Rt[9];
		ceres::AngleAxisToRotationMatrix(Parameters[1], Rt);//this gives R' due to its column major format

		T RefRayDir[3] = { (T)0.0, (T) 0.0, (T) 0.0 };
		for (int ii = 0; ii < 3; ii++)
			for (int jj = 0; jj < 3; jj++)
				RefRayDir[ii] += Rt[ii * 3 + jj] * (T)xycnRef[jj]; //ray direction: r = R'*iK*i;

		T camCenter[3] = { (T)0.0, (T) 0.0, (T) 0.0 };
		for (int ii = 0; ii < 3; ii++)
			for (int jj = 0; jj < 3; jj++)
				camCenter[ii] += Rt[ii * 3 + jj] * Parameters[1][jj + 3]; ////-C = R't;

		T XYZ[3], d = Parameters[0][0];
		for (int ii = 0; ii < 3; ii++)
			XYZ[ii] = RefRayDir[ii] / d - camCenter[ii]; //X = r*d+c

		//project to other views
		T tp[3], xcn, ycn, tu, tv, color[3];
		ceres::AngleAxisRotatePoint(&Parameters[2][0], XYZ, tp);
		tp[0] += Parameters[2][3], tp[1] += Parameters[2][4], tp[2] += Parameters[2][5];
		xcn = tp[0] / tp[2], ycn = tp[1] / tp[2];

		tu = (T)intrinsic[0] * xcn + (T)intrinsic[2] * ycn + (T)intrinsic[3];
		tv = (T)intrinsic[1] * ycn + (T)intrinsic[4];

		if (nchannels == 1)
		{
			Grid2D<uchar, 1>  img(nonRefImgs, 0, imgSize.y, 0, imgSize.x);
			BiCubicInterpolator<Grid2D < uchar, 1 > > Imgs(img);

			if (tu<(T)50 || tu>(T)(imgSize.x - 50) || tv<(T)50 || tv>(T)(imgSize.y - 50))
				residuals[0] = (T)1000;
			else
			{
				Imgs.Evaluate(tv, tu, color);//ceres takes row, column
				uchar refColor = refImg[uv.x + uv.y*imgSize.x];
				//T dif = Parameters[3][0] * color[0] + Parameters[3][1] - (T)(double)(int)refColor;
				T dif = Parameters[3][0] * color[0] + Parameters[3][1] - (T)(double)(int)refColor;
				residuals[0] = (T)isigma*dif;
			}
		}
		else
		{
			Grid2D<uchar, 3>  img(nonRefImgs, 0, imgSize.y, 0, imgSize.x);
			BiCubicInterpolator<Grid2D < uchar, 3 > > Imgs(img);

			if (tu<(T)50 || tu>(T)(imgSize.x - 50) || tv<(T)50 || tv>(T)(imgSize.y - 50))
				for (int jj = 0; jj < nchannels; jj++)
					residuals[jj] = (T)1000;
			else
			{
				Imgs.Evaluate(tv, tu, color);//ceres takes row, column
				for (int jj = 0; jj < nchannels; jj++)
				{
					uchar refColor = refImg[uv.x*nchannels + uv.y*imgSize.x*nchannels + jj];
					T dif = Parameters[3][0] * color[jj] + Parameters[3][1] - (T)(double)(int)refColor;
					residuals[jj] = (T)isigma*dif;
				}
			}
		}

		return true;
	}

private:
	uchar *refImg, *nonRefImgs;
	Point2i uv, imgSize;
	double xycnRef[3], *intrinsic, isigma;
	int  nchannels, eleID, imgID;
};
struct IntraDepthRegularize {
	IntraDepthRegularize(double isigma) : isigma(isigma){}

	template <typename T>	bool operator()(const T* const idepth1, const T* const idepth2, T* residuals) 	const
	{
		T num = idepth2[0] - idepth1[0];
		T denum = idepth1[0] * idepth2[0];
		residuals[0] = (T)isigma*num / (denum + (T) 1.0e-16); //1/id1 - 1/id2 ~ (id2 - id1)/(id1*id2 + esp)
		return true;
	}

	static ceres::CostFunction* Create(const double isigma)
	{
		return (new ceres::AutoDiffCostFunction<IntraDepthRegularize, 1, 1, 1>(new IntraDepthRegularize(isigma)));
	}

	static ceres::CostFunction* CreateNumerDiff(const double isigma)
	{
		return (new ceres::NumericDiffCostFunction<IntraDepthRegularize, ceres::CENTRAL, 1, 1, 1>(new IntraDepthRegularize(isigma)));
	}

	double isigma;
};

/*class NNDepthRegularize
{
public:
NNDepthRegularize(int* sub2indNonRef, double *invdNonRef, int width) : sub2indNonRef(sub2indNonRef), invdNonRef(invdNonRef), width(width){};

// The following two Evaluate overloads are needed for interfacing with automatic differentiation. The first is for when a scalar evaluation is done, and the second one is for when Jets are used.
void Evaluate(const double &x, const double &y, double* f) const
{
int ix = std::floor(x), iy = std::floor(y);
if (x - ix > 0.5)
ix++;
if (y - iy > 0.5)
iy++;

f[0] = invdNonRef[sub2indNonRef[ix + iy*width]];
}
template<typename JetT> void Evaluate(const JetT& x, const JetT &y, JetT* f) const
{
double fx, dfdx;
int ix = std::floor(x), iy = std::floor(y);
if (x - ix > 0.5)
ix++;
if (y - iy > 0.5)
iy++;

f[0].a = invdNonRef[sub2indNonRef[ix + iy*width]];
f[0].v = 0.0;
}

private:
int width;
int*sub2indNonRef;
double *invdNonRef;
};
class NNDepthRegularize : public SizedCostFunction<1, 1, 1>
{
public:
NNDepthRegularize(double x, double y, int* sub2indNonRef, int width) : x(x), y(y), sub2indNonRef(sub2indNonRef), width(width){};

virtual bool Evaluate(double const *const *parameters, double *residuals, double **jacobians) const
{
double fx, dfdx;
int ix = std::floor(x), iy = std::floor(y);
if (x - ix > 0.5)
ix++;
if (y - iy > 0.5)
iy++;
int id = sub2indNonRef[ix + iy*width];

double RefInvD = parameters[0][0];
double nonRefInvD = parameters[0][id];

residuals[0] = (nonRefInvD - RefInvD) / (RefInvD*nonRefInvD + 1.0e-16);

if (jacobians != NULL && jacobians[0] != NULL)
{
jacobians[0][0] = -1.0 / RefInvD / RefInvD;
jacobians[0][1] = 1.0 / nonRefInvD / nonRefInvD;
}
return true;
}
int width;
double x, y;
int *sub2indNonRef;
};

struct InterDepthRegularize
{
InterDepthRegularize(const double *rayDir, CameraData *allCalibInfo, int* sub2indNonRef, int RefCid, int nonRefCid, double isigma) : allCalibInfo(allCalibInfo), sub2indNonRef(sub2indNonRef), RefCid(RefCid), nonRefCid(nonRefCid), isigma(isigma)
{
for (int ii = 0; ii < 3; ii++)
rayDirection[ii] = rayDir[ii];
}

template <typename T>	bool operator()(const T* const idepth1, const T* const idepth2, const T* const rt, T* residuals) 	const
{
T XYZ[3], d = idepth1[0];
for (int ii = 0; ii < 3; ii++)
XYZ[ii] = (T)rayDirection[ii] / d + (T)allCalibInfo[RefCid].camCenter[ii];

//project to other views
T tp[3], xcn, ycn, tu, tv, color[3];
ceres::AngleAxisRotatePoint(rt, XYZ, tp);
tp[0] += rt[3], tp[1] += rt[4], tp[2] += rt[5];
xcn = tp[0] / tp[2], ycn = tp[1] / tp[2];

tu = (T)allCalibInfo[nonRefCid].intrinsic[0] * xcn + (T)allCalibInfo[nonRefCid].intrinsic[2] * ycn + (T)allCalibInfo[nonRefCid].intrinsic[3];
tv = (T)allCalibInfo[nonRefCid].intrinsic[1] * ycn + (T)allCalibInfo[nonRefCid].intrinsic[4];

if (tu<(T)50 || tu>(T)(allCalibInfo[nonRefCid].width - 50) || tv<(T)50 || tv>(T)(allCalibInfo[nonRefCid].height - 50))
residuals[0] = (T)1000;
else
{
//compute depth at the nonRefCid
T r[3] = { (T)allCalibInfo[nonRefCid].rt[0], (T)allCalibInfo[nonRefCid].rt[1], (T)allCalibInfo[nonRefCid].rt[2] }, Rt[9];
T xycn1[3] = { xcn, ycn, (T) 0.0 }, nonRefRayDir[3] = { (T)0.0, (T)0.0, (T)0.0 };
ceres::AngleAxisToRotationMatrix(r, Rt);//this gives R' due to its column major format

for (int ii = 0; ii < 3; ii++)
for (int jj = 0; jj < 3; jj++)
nonRefRayDir[ii] += Rt[ii * 3 + jj] * xycn1[jj]; //ray direction: r = R'*iK*i;

T invdRef;
if (nonRefRayDir[0] > nonRefRayDir[1] && nonRefRayDir[0]>nonRefRayDir[2])
invdRef = (XYZ[0] - allCalibInfo[nonRefCid].camCenter[0]) / nonRefRayDir[0]; //depth = (X - cc)/r;
else if (nonRefRayDir[1] > nonRefRayDir[0] && nonRefRayDir[1] > nonRefRayDir[2])
invdRef = (XYZ[1] - allCalibInfo[nonRefCid].camCenter[1]) / nonRefRayDir[1];
else
invdRef = (XYZ[2] - allCalibInfo[nonRefCid].camCenter[2]) / nonRefRayDir[2];

//look up for the depth of the nearest pixel
residuals[0] = (T)isigma*residuals[0];

return true;
}

return true;
}

static ceres::CostFunction* Create(double *rayDir, CameraData *allCalibInfo, int *sub2indNonRef, int RefCid, int nonRefCid, double isigma)
{
return (new ceres::AutoDiffCostFunction<InterDepthRegularize, 1, 1, 1, 6>(new InterDepthRegularize(rayDir, allCalibInfo, sub2indNonRef, RefCid, nonRefCid, isigma)));
}

int*sub2indNonRef;
double rayDirection[3], isigma;
int RefCid, nonRefCid;
CameraData *allCalibInfo;
};*/

struct InterDepthRegularize
{
	InterDepthRegularize(double *xycnRef_, int* sub2indNonRef, double *NonRefintrinsic, int width, int height, double isigma) : CalibInfo(CalibInfo), sub2indNonRef(sub2indNonRef), NonRefintrinsic(NonRefintrinsic), width(width), height(height), isigma(isigma)
	{
		for (int ii = 0; ii < 3; ii++)
			xycnRef[ii] = xycnRef_[ii];
	}
	template <typename T>	bool operator()(const double* const idepth1, const double* const idepth2, const double* const rt0, const double* const rt1, T* residuals) const
	{
		double Rt[9];
		ceres::AngleAxisToRotationMatrix(rt0, Rt);//this gives R' due to its column major format

		double RefRayDir[3] = { 0.0, 0.0, 0.0 };
		for (int ii = 0; ii < 3; ii++)
			for (int jj = 0; jj < 3; jj++)
				RefRayDir[ii] += Rt[ii * 3 + jj] * xycnRef[jj]; //ray direction: r = R'*iK*i;

		double camCenter[3] = { 0, 0, 0 };
		for (int ii = 0; ii < 3; ii++)
			for (int jj = 0; jj < 3; jj++)
				camCenter[ii] += Rt[ii * 3 + jj] * rt0[jj + 3]; ////-C = R't;

		double XYZ[3], d = idepth1[0];
		for (int ii = 0; ii < 3; ii++)
			XYZ[ii] = RefRayDir[ii] / d - camCenter[ii]; //X = r*d+c

		//project to other views
		double tp[3], xcn, ycn, tu, tv, color[3];
		ceres::AngleAxisRotatePoint(rt1, XYZ, tp);
		tp[0] += rt1[3], tp[1] += rt1[4], tp[2] += rt1[5];
		xcn = tp[0] / tp[2], ycn = tp[1] / tp[2];

		tu = NonRefintrinsic[0] * xcn + NonRefintrinsic[2] * ycn + NonRefintrinsic[3];
		tv = NonRefintrinsic[1] * ycn + NonRefintrinsic[4];

		if (tu<50 || tu>(width - 50) || tv<50 || tv>(height - 50))
			residuals[0] = 1000;
		else
		{
			//compute depth at the nonRefCid
			double xycnNonRef[3] = { xcn, ycn, 0.0 }, nonRefRayDir[3] = { 0.0, 0.0, 0.0 };
			ceres::AngleAxisToRotationMatrix(rt1, Rt);//this gives R' due to its column major format
			for (int ii = 0; ii < 3; ii++)
				for (int jj = 0; jj < 3; jj++)
					nonRefRayDir[ii] += Rt[ii * 3 + jj] * xycnNonRef[jj]; //ray direction: r = R'*iK*i;

			for (int ii = 0; ii < 3; ii++)
			{
				camCenter[ii] = 0;
				for (int jj = 0; jj < 3; jj++)
					camCenter[ii] += Rt[ii * 3 + jj] * rt1[jj + 3]; ////-C = R't;
			}

			double invdRef;
			if (nonRefRayDir[0] > nonRefRayDir[1] && nonRefRayDir[0] > nonRefRayDir[2])
				invdRef = (XYZ[0] + camCenter[0]) / nonRefRayDir[0]; //depth = (X - cc)/r;
			else if (nonRefRayDir[1] > nonRefRayDir[0] && nonRefRayDir[1] > nonRefRayDir[2])
				invdRef = (XYZ[1] + camCenter[1]) / nonRefRayDir[1];
			else
				invdRef = (XYZ[2] + camCenter[2]) / nonRefRayDir[2];

			//look up for the depth of the nearest pixel
			int rtu = std::floor(tu), rtv = std::floor(tv);
			if (tu - rtu > 0.5)
				rtu++;
			if (tv - rtv > 0.5)
				rtv++;

			double invdNonRef = idepth2[sub2indNonRef[rtu + rtv*width]];
			if (invdNonRef < 0)
				residuals[0] = 1000;
			else
				residuals[0] = isigma*(invdNonRef - invdRef) / (invdRef*invdNonRef + 1.0e-16);
		}

		return true;
	}

	static ceres::CostFunction* Create(double *rayDir, int *sub2indNonRef, double *NonRefintrinsic, int width, int height, double isigma)
	{
		return (new ceres::NumericDiffCostFunction<InterDepthRegularize, ceres::CENTRAL, 1, 1, 1, 6, 6>(new InterDepthRegularize(rayDir, sub2indNonRef, NonRefintrinsic, width, height, isigma)));
	}

	int width, height;
	int*sub2indNonRef;
	double *NonRefintrinsic, xycnRef[3], isigma;
	CameraData *CalibInfo;
};

int DirectAlignment(vector<ImgData> &allImgs, vector<CameraData> &allCalibInfo)
{
	double dataWeight = 0.8, regIntraWeight = 0.2, regInterWeight = 1.0 - dataWeight - regIntraWeight;
	double colorSigma = 5.0, depthSigma = 2; //expected std of variables (grayscale, mm);
	int boundary = 50, width = allImgs[0].width, height = allImgs[0].height, nchannels = allImgs[0].nchannels;

	//find texture region in the refImg and store in the vector
	for (int cid = 0; cid < (int)allImgs.size(); cid++)
		GaussianBlur(allImgs[cid].color, allImgs[cid].color, Size(5, 5), 0, 0);

	//calculate first order image derivatives: using 1 channel should be enough
	vector<float *> dxAll, dyAll;
	for (int cid = 0; cid < (int)allImgs.size(); cid++)
	{
		float *dx = new float[width*height], *dy = new float[width*height];
		for (int jj = boundary; jj < height - boundary; jj++)
		{
			for (int ii = boundary; ii < width - boundary; ii++)
			{
				dx[ii + jj*width] = (float)(int)allImgs[0].color.data[(ii + 1)*nchannels + jj*nchannels*width + 0] - (float)(int)allImgs[0].color.data[(ii - 1)*nchannels + jj*nchannels*width + 0]; //-1, 0, 1
				dy[ii + jj*width] = (float)(int)allImgs[0].color.data[ii *nchannels + (jj + 1)*nchannels*width + 0] - (float)(int)allImgs[0].color.data[ii *nchannels + (jj - 1)*nchannels*width + 0]; //-1, 0, 1
			}
		}
		dxAll.push_back(dx), dyAll.push_back(dy);
	}

	//Getting valid pixels (high texture && has depth &&good conf)
	float mag2Thresh = 80;
	vector<bool *> validPixelsAll;
	vector<int*> sub2indAll;
	vector<int> *indIAll = new vector<int>[allImgs.size()], *indJAll = new vector<int>[allImgs.size()];
	vector<double> *invDAll = new vector<double>[allImgs.size()];
	for (int cid = 0; cid < (int)allImgs.size(); cid++)
	{
		int *sub2ind = new int[width*height];
		bool *validPixels = new bool[width*height];
		for (int ii = 0; ii < width*height; ii++)
			validPixels[ii] = false, sub2ind[ii] = -1;

		invDAll[cid].reserve(width*height);
		indIAll[cid].reserve(width*height), indJAll[cid].reserve(width*height);

		for (int jj = boundary; jj < height - boundary; jj++)
		{
			for (int ii = boundary; ii < width - boundary; ii++)
			{
				float mag2 = pow(dxAll[cid][ii + jj*width], 2) + pow(dyAll[cid][ii + jj*width], 2);
				if (IsNumber(allImgs[cid].depth[ii + jj*width]) == 1 && mag2 > mag2Thresh  && allImgs[cid].depth[ii + jj*width] > 0)// && allImgs[0].depthConf[ii + jj*width] >70)
				{
					indIAll[cid].push_back(ii), indJAll[cid].push_back(jj), invDAll[cid].push_back(1.0 / (allImgs[0].depth[ii + jj*width] + 1.0e-9)), validPixels[ii + jj*width] = true, sub2ind[ii + jj*width] = (int)indIAll[cid].size() - 1;
				}
			}
		}
		validPixelsAll.push_back(validPixels), sub2indAll.push_back(sub2ind);
	}

	//detecting nearby pixels for regularization
	vector<vector<int> > nNNAll;
	vector<vector<int*> > NNAll;
	for (int cid = 0; cid < (int)allImgs.size(); cid++)
	{
		vector<int*> NN; NN.reserve(width*height);
		vector<int> nNN; nNN.reserve(width*height);
		for (int jj = boundary; jj < height - boundary; jj++)
		{
			for (int ii = boundary; ii < width - boundary; ii++)
			{
				if (validPixelsAll[cid][ii + jj*width])
				{
					int count = 0;
					int *nn = new int[4];
					nn[count] = sub2indAll[cid][ii + jj*width], count++;
					if (validPixelsAll[cid][ii - 1 + jj*width])
						nn[count] = sub2indAll[cid][ii - 1 + jj*width], count++;
					if (validPixelsAll[cid][ii + 1 + jj*width])
						nn[count] = sub2indAll[cid][ii + 1 + jj*width], count++;
					if (validPixelsAll[cid][ii + (jj - 1)*width])
						nn[count] = sub2indAll[cid][ii + (jj - 1)*width], count++;
					if (validPixelsAll[cid][ii + (jj + 1)*width])
						nn[count] = sub2indAll[cid][ii + (jj + 1)*width], count++;
					NN.push_back(nn);
					nNN.push_back(count);
				}
			}
		}
		nNNAll.push_back(nNN), NNAll.push_back(NN);
	}

	for (int ii = 0; ii < (int)allImgs.size(); ii++)
		for (int jj = 0; jj < (int)allImgs.size(); jj++)
			allCalibInfo[ii].photometric.push_back(1.0), allCalibInfo[ii].photometric.push_back(0);

	{
		//Sliding the parameters
		double orgx = allCalibInfo[1].rt[0], orgy = allCalibInfo[1].rt[1], orgz = allCalibInfo[1].rt[2];
		FILE *fp = fopen("C:/temp/costZ.txt", "w+");

		Grid2D<uchar, 1>  img1(allImgs[1].color.data, 0, allImgs[1].height, 0, allImgs[1].width);
		BiCubicInterpolator<Grid2D < uchar, 1 > > imgInterp1(img1);

		Grid2D<uchar, 3>  img3(allImgs[1].color.data, 0, allImgs[1].height, 0, allImgs[1].width);
		BiCubicInterpolator<Grid2D < uchar, 3 > > imgInterp3(img3);

		
		for (int x = 0; x <= 0; x++)
		{
			//omp_set_num_threads(omp_get_max_threads());
//#pragma omp parallel for schedule(dynamic,1)
			for (int y = -0; y <= 0; y++)
			{
				for (int z = -25; z <= 25; z++)
				{
					printf("(%d, %d, %d)... ", x, y, z);
					int cidJ = 0, cidI = 1, npts = 0;
					double residuals = 0.0, R[9], rt[6] = { orgx + 0.005*x, orgy + 0.005*y, orgz + 0.005*z, allCalibInfo[1].rt[3], allCalibInfo[1].rt[4], allCalibInfo[1].rt[5] };

					//for (int cidJ = 0; cidJ < (int)allImgs.size(); cidJ++)
					{
						int cidJ = 0;
						bool once = true;
						for (int cidI = 0; cidI < (int)allImgs.size(); cidI++)
						{
							if (cidI == cidJ)
								continue;

							for (int ii = 0; ii < (int)invDAll[cidJ].size(); ii++)
							{
								int i = indIAll[cidJ][ii], j = indJAll[cidJ][ii];
								double xycnRef[3] = { 0, 0, 0 }, ij[3] = { i, j, 1 };
								mat_mul(allCalibInfo[cidJ].invK, ij, xycnRef, 3, 3, 1);

								ceres::DynamicAutoDiffCostFunction<DepthImgWarping, 4> *cost_function = new ceres::DynamicAutoDiffCostFunction < DepthImgWarping, 4 >
									(new DepthImgWarping(Point2i(i, j), xycnRef, allImgs[cidJ].color.data, allImgs[cidI].color.data, allCalibInfo[cidI].intrinsic, Point2i(allImgs[cidI].width, allImgs[cidI].height), allImgs[cidI].nchannels, 1.0 / colorSigma, ii, cidI));

								cost_function->SetNumResiduals(nchannels);

								vector<double*> parameter_blocks;
								parameter_blocks.push_back(&invDAll[cidJ][ii]), cost_function->AddParameterBlock(1);
								parameter_blocks.push_back(allCalibInfo[cidJ].rt), cost_function->AddParameterBlock(6);
								parameter_blocks.push_back(rt), cost_function->AddParameterBlock(6);
								parameter_blocks.push_back(&allCalibInfo[cidI].photometric[2 * cidJ]), cost_function->AddParameterBlock(2);

								double resi;
								cost_function->Evaluate(&parameter_blocks[0], &resi, NULL);
								residuals += resi*resi;

								delete[]cost_function;
								npts += nchannels;
							}
						}
					}
#pragma omp critical
					fprintf(fp, "%.3f %.3f %.3f %.16e\n", 0.005*x, 0.005*y, 0.005*z, residuals / (0.001 + npts));
				}
			}
		}
		fclose(fp);
		return 0;
	}


	//dump to Ceres
	ceres::Problem problem;

	//Data term
	ceres::LossFunction *ColorLoss = NULL;// new ceres::TukeyLoss(5);
	ceres::LossFunction* ScaleColorLoss = new ceres::ScaledLoss(ColorLoss, dataWeight, ceres::TAKE_OWNERSHIP);
	//for (int cidJ = 0; cidJ < (int)allImgs.size(); cidJ++)
	{
		int cidJ = 0;
		bool once = true;
		for (int cidI = 0; cidI < (int)allImgs.size(); cidI++)
		{
			if (cidI == cidJ)
				continue;

			for (int ii = 0; ii < (int)invDAll[cidJ].size(); ii++)
			{
				int i = indIAll[cidJ][ii], j = indJAll[cidJ][ii];
				double xycnRef[3] = { 0, 0, 0 }, ij[3] = { i, j, 1 };
				mat_mul(allCalibInfo[cidJ].invK, ij, xycnRef, 3, 3, 1);

				ceres::DynamicNumericDiffCostFunction<DepthImgWarping, ceres::CENTRAL> *cost_function = new ceres::DynamicNumericDiffCostFunction<DepthImgWarping, ceres::CENTRAL>
					(new DepthImgWarping(Point2i(i, j), xycnRef, allImgs[cidJ].color.data, allImgs[cidI].color.data, allCalibInfo[cidI].intrinsic, Point2i(allImgs[cidI].width, allImgs[cidI].height), allImgs[cidI].nchannels, 1.0 / colorSigma, ii, cidI));
				//ceres::DynamicAutoDiffCostFunction<DepthImgWarping, 4> *cost_function = new ceres::DynamicAutoDiffCostFunction < DepthImgWarping, 4 >
				//	(new DepthImgWarping(Point2i(i, j), xycnRef, allImgs[cidJ].color.data, allImgs[cidI].color.data, allCalibInfo[cidI].intrinsic, Point2i(allImgs[cidI].width, allImgs[cidI].height), allImgs[cidI].nchannels, 1.0 / colorSigma, ii, cidI));

				cost_function->SetNumResiduals(nchannels);

				vector<double*> parameter_blocks;
				parameter_blocks.push_back(&invDAll[cidJ][ii]), cost_function->AddParameterBlock(1);
				parameter_blocks.push_back(allCalibInfo[cidJ].rt), cost_function->AddParameterBlock(6);
				parameter_blocks.push_back(allCalibInfo[cidI].rt), cost_function->AddParameterBlock(6);
				parameter_blocks.push_back(&allCalibInfo[cidI].photometric[2 * cidJ]), cost_function->AddParameterBlock(2);
				problem.AddResidualBlock(cost_function, ScaleColorLoss, parameter_blocks);

				problem.SetParameterBlockConstant(parameter_blocks[0]); //depth
				problem.SetParameterBlockConstant(parameter_blocks[1]); //pose Ref
				if (once)
				{
					std::vector<int> constant_parameters;
					for (int jj = 3; jj < 6; jj++)
						constant_parameters.push_back(jj);
					problem.SetParameterization(allCalibInfo[cidI].rt, new ceres::SubsetParameterization(6, constant_parameters));
					once = false;
				}

				//problem.SetParameterBlockConstant(parameter_blocks[2]); //pose nonRef
				problem.SetParameterBlockConstant(parameter_blocks[3]); //photometric
			}
		}
	}

	//Intra depth regularization term
	/*ceres::LossFunction *RegIntraLoss = NULL;
	ceres::LossFunction* ScaleRegIntraLoss = new ceres::ScaledLoss(RegIntraLoss, regIntraWeight, ceres::TAKE_OWNERSHIP);
	for (int cid = 0; cid < (int)allImgs.size(); cid++)
	{
	for (int ii = 0; ii < (int)NNAll[cid].size(); ii++)
	{
	for (int jj = 1; jj < (int)nNNAll[cid][ii]; jj++)
	{
	ceres::CostFunction* cost_function = IntraDepthRegularize::Create(1.0 / depthSigma);
	problem.AddResidualBlock(cost_function, ScaleRegIntraLoss, &invDAll[cid][NNAll[cid][ii][0]], &invDAll[cid][NNAll[cid][ii][jj]]);
	}
	}
	}*/

	/*//Inter depth regularization term
	ceres::LossFunction *RegInterLoss = NULL;
	ceres::LossFunction* ScaleRegInterLoss = new ceres::ScaledLoss(RegInterLoss, regInterWeight, ceres::TAKE_OWNERSHIP);
	for (int cidJ = 0; cidJ < (int)allImgs.size(); cidJ++)
	{
	for (int cidI = 0; cidI < (int)allImgs.size(); cidI++)
	{
	if (cidI == cidJ)
	continue;

	for (int ii = 0; ii < (int)invDAll[cidJ].size(); ii++)
	{
	double xycnRef[3] = { 0, 0, 0 }, ij[3] = { indIAll[cidJ][ii], indJAll[cidJ][ii], 1 };
	mat_mul(allCalibInfo[cidJ].invK, ij, xycnRef, 3, 3, 1);

	ceres::CostFunction* cost_function = InterDepthRegularize::Create(xycnRef, sub2indAll[cidI], allCalibInfo[cidI].intrinsic, allCalibInfo[cidI].width, allCalibInfo[cidI].height, 0.5 / depthSigma);
	problem.AddResidualBlock(cost_function, ScaleRegInterLoss, &invDAll[cidJ][0], &invDAll[cidI][0], allCalibInfo[cidJ].rt, allCalibInfo[cidI].rt);
	}
	}
	}*/

	//Set up callback to update residual images
	int iter = 0;
	class MyCallBack : public ceres::IterationCallback{
	public:
		MyCallBack(std::function<void()> callback, int &iter) : callback_(callback), iter(iter){}
		virtual ~MyCallBack() {}

		ceres::CallbackReturnType operator()(const ceres::IterationSummary& summary)
		{
			iter = summary.iteration;
			if (iter == 0 || summary.step_is_successful)
				callback_();
			return ceres::SOLVER_CONTINUE;
		}
		int &iter;
		std::function<void()> callback_;
	};
	auto update_Result = [&]()
	{
		char Fname[512];
		uchar *resImg = new uchar[allImgs[0].height* allImgs[0].width* nchannels];
		float *depthMap = new float[allImgs[0].height* allImgs[0].width];

		//for (int cidJ = 0; cidJ < (int)allImgs.size(); cidJ++)
		{
			int cidJ = 0;
			int npts = 0;
			double residuals = 0.0;
			for (int cidI = 0; cidI < (int)allImgs.size(); cidI++)
			{
				if (cidI == cidJ)
					continue;

				for (int ii = 0; ii < allImgs[0].height* allImgs[0].width; ii++)
					depthMap[ii] = 0.f;
				for (int ii = 0; ii < allImgs[cidI].height* allImgs[cidI].width* nchannels; ii++)
					resImg[ii] = (uchar)255;

				//vector<double> colorProfile; colorProfile.reserve(invD.size());
				for (int ii = 0; ii < (int)invDAll[cidJ].size(); ii++)
				{
					double rayDirRef[3], ij[3] = { indIAll[cidJ][ii], indJAll[cidJ][ii], 1 };
					getRfromr(allCalibInfo[cidJ].rt, allCalibInfo[cidJ].R);
					getRayDir(rayDirRef, allCalibInfo[cidJ].invK, allCalibInfo[cidJ].R, ij);

					double d = invDAll[cidJ][ii];
					depthMap[indIAll[cidJ][ii] + indJAll[cidJ][ii] * allImgs[cidJ].width] = 1.0 / d;

					//back-project ref depth to 3D
					double XYZ[3];
					GetCfromT(allCalibInfo[cidJ].R, allCalibInfo[cidJ].T, allCalibInfo[cidJ].camCenter);
					for (int jj = 0; jj < 3; jj++)
						XYZ[jj] = rayDirRef[jj] / d + allCalibInfo[cidJ].camCenter[jj];

					//back project to other views
					double tp[3], xcn, ycn, tu, tv, color[3];
					ceres::AngleAxisRotatePoint(allCalibInfo[cidI].rt, XYZ, tp);
					tp[0] += allCalibInfo[cidI].rt[3], tp[1] += allCalibInfo[cidI].rt[4], tp[2] += allCalibInfo[cidI].rt[5];
					xcn = tp[0] / tp[2], ycn = tp[1] / tp[2];

					tu = allCalibInfo[cidI].intrinsic[0] * xcn + allCalibInfo[cidI].intrinsic[2] * ycn + allCalibInfo[cidI].intrinsic[3];
					tv = allCalibInfo[cidI].intrinsic[1] * ycn + allCalibInfo[cidI].intrinsic[4];

					if (tu<1 || tu> allImgs[cidI].width - 2 || tv<1 || tv>allImgs[cidI].height - 2)
						continue;

					if (nchannels == 1)
					{
						Grid2D<uchar, 1>  img(allImgs[cidI].color.data, 0, allImgs[cidI].height, 0, allImgs[cidI].width);
						BiCubicInterpolator<Grid2D < uchar, 1 > > imgInterp(img);

						imgInterp.Evaluate(tv, tu, color);//ceres takes row, column
						double fcolor = allCalibInfo[cidI].photometric[2 * cidJ] * color[0] + allCalibInfo[cidI].photometric[2 * cidJ + 1];
						double dif = fcolor - (double)(int)allImgs[cidJ].color.data[indIAll[cidJ][ii] + indJAll[cidJ][ii] * allImgs[cidJ].width];

						//resImg[indI[ii] + indJ[ii] * allImgs[0].width] = (uchar)(int)(10 * abs(dif + 0.5)); //magnify 10x
						resImg[indIAll[cidJ][ii] + indJAll[cidJ][ii] * allImgs[cidJ].width] = (uchar)(int)(fcolor + 0.5);

						residuals += dif*dif;
						npts++;
					}
					else
					{
						Grid2D<uchar, 3>  img(allImgs[cidI].color.data, 0, allImgs[cidI].height, 0, allImgs[cidI].width);
						BiCubicInterpolator<Grid2D < uchar, 3 > > imgInterp(img);

						imgInterp.Evaluate(tv, tu, color);//ceres takes row, column

						for (int jj = 0; jj < 3; jj++)
						{
							double fcolor = allCalibInfo[cidI].photometric[2 * cidJ] * color[jj] + allCalibInfo[cidI].photometric[2 * cidJ + 1];
							double dif = fcolor - (double)(int)allImgs[cidJ].color.data[indIAll[cidI][ii] + jj + indJAll[cidI][ii] * allImgs[cidJ].width*nchannels];

							//resImg[indI[ii] + indJ[ii] * allImgs[0].width] = (uchar)(int)(10 * abs(dif + 0.5)); //magnify 10x
							resImg[indIAll[cidJ][ii] + indJAll[cidJ][ii] * allImgs[cidJ].width + jj*allImgs[cidJ].width*allImgs[cidJ].height] = (uchar)(int)(fcolor + 0.5);
							residuals += dif*dif;
							npts += 3;
						}
					}
				}

				//sprintf(Fname, "C:/temp/%d_%d_%d.dat", cidJ, cidI, iter), WriteGridBinary(Fname, resImg, allImgs[cidJ].width, allImgs[cidJ].height, nchannels);
				sprintf(Fname, "C:/temp/%d_%d_%d.png", cidJ, cidI, iter), WriteGridToImage(Fname, resImg, allImgs[cidJ].width, allImgs[cidJ].height, nchannels);

				sprintf(Fname, "C:/temp/pose_%d.txt", cidJ); FILE *fp = fopen(Fname, "a+");
				fprintf(fp, "%d %.16f %.16f %.16f %.16f %.16f %.16f %.4f %.4f \n", iter, allCalibInfo[cidI].rt[0], allCalibInfo[cidI].rt[1], allCalibInfo[cidI].rt[2], allCalibInfo[cidI].rt[3], allCalibInfo[cidI].rt[4], allCalibInfo[cidI].rt[5], allCalibInfo[cidI].photometric[2 * cidJ], allCalibInfo[cidI].photometric[2 * cidJ + 1]);
				fclose(fp);
			}
			sprintf(Fname, "C:/temp/iter_%d.txt", cidJ); FILE *fp = fopen(Fname, "a"); fprintf(fp, "%d %.16e\n", iter, sqrt(residuals / npts)); fclose(fp);
			//sprintf(Fname, "C:/temp/D_%d_%d.dat", cidI, iter), WriteGridBinary(Fname, depthMap, allImgs[cidI].width, allImgs[cidI].height, 1);
		}

		/*sprintf(Fname, "C:/temp/3d_%d.xyz", iter); FILE *fp = fopen(Fname, "w+");
		for (int ii = 0; ii < (int)invDAll[0].size(); ii++)
		{
		double XYZ[3], rayDir[3], ij[3] = { indIAll[0][ii], indJAll[0][ii], 1 };
		getRayDir(rayDir, allCalibInfo[0].invK, allCalibInfo[0].R, ij);

		for (int kk = 0; kk < 3; kk++)
		XYZ[kk] = rayDir[kk] / invDAll[0][ii] + allCalibInfo[0].camCenter[kk];
		fprintf(fp, "%.8e %.8e %.8e\n", XYZ[0], XYZ[1], XYZ[2]);
		}
		fclose(fp);*/

		delete[]depthMap;
		delete[]resImg;
	};
	for (int cid = 0; cid < (int)allImgs.size(); cid++)
	{
		char Fname[512]; sprintf(Fname, "C:/temp/iter_%d.txt", cid);
		FILE *fp = fopen(Fname, "w+"); fclose(fp);
	}


	printf("...run BA...\n");
	ceres::Solver::Options options;
	options.update_state_every_iteration = true;
	options.callbacks.push_back(new MyCallBack(update_Result, iter));

	options.num_threads = omp_get_max_threads(); //jacobian eval
	options.num_linear_solver_threads = omp_get_max_threads(); //linear solver
	//options.dynamic_sparsity = true;
	options.trust_region_strategy_type = ceres::LEVENBERG_MARQUARDT;
	options.linear_solver_type = ceres::CGNR;
	options.preconditioner_type = ceres::JACOBI;
	options.use_inner_iterations = true;
	options.use_nonmonotonic_steps = false;
	options.max_num_iterations = 50;
	options.parameter_tolerance = 1.0e-12;
	options.minimizer_progress_to_stdout = true;

	ceres::Solver::Summary summary;
	ceres::Solve(options, &problem, &summary);
	std::cout << summary.FullReport() << "\n";

	printf("Saving data...");
	for (int cid = 0; cid < (int)allImgs.size(); cid++)
	{
		FILE *fp = fopen("C:/temp/3d.xyz", "w+");
		for (int ii = 0; ii < (int)invDAll[cid].size(); ii++)
		{
			double XYZ[3], rayDir[3], ij[3] = { indIAll[cid][ii], indJAll[cid][ii], 1 };
			getRayDir(rayDir, allCalibInfo[0].invK, allCalibInfo[0].R, ij);

			for (int kk = 0; kk < 3; kk++)
				XYZ[kk] = rayDir[kk] / invDAll[cid][ii] + allCalibInfo[0].camCenter[kk];
			fprintf(fp, "%.8e %.8e %.8e\n", XYZ[0], XYZ[1], XYZ[2]);
		}
		fclose(fp);
	}

	FILE *fp = fopen("C:/temp/pose.txt", "w+");
	for (int cid = 0; cid < (int)allImgs.size(); cid++)
		fprintf(fp, "%.16f %.16f %.16f %.16f %.16f %.16f\n", allCalibInfo[cid].rt[0], allCalibInfo[cid].rt[1], allCalibInfo[cid].rt[2], allCalibInfo[cid].rt[3], allCalibInfo[cid].rt[4], allCalibInfo[cid].rt[5]);
	for (int cid = 0; cid < (int)allImgs.size(); cid++)
		fprintf(fp, "%.4f %.4f \n", allCalibInfo[cid].photometric[0], allCalibInfo[cid].photometric[1]);
	fclose(fp);

	printf("Done\n");

	return 1;
}

int MousePosX, MousePosY, clicked;
static void onMouse(int event, int x, int y, int, void*)
{
	if (event == EVENT_LBUTTONDBLCLK)
	{
		MousePosX = x, MousePosY = y, clicked = 1;
		printf("Selected: %d %d\n", x, y);
		cout << "\a";
	}
}

int main(int argc, char** argv)
{
	char Fname[512], Path[] = "D:/Source/Repos/Users/sudipsin/recon3D/data/Y";

	{
		double focal = 3968.297, baseline = 236.922, doffs = 77.215;

		CameraData Cam1, Cam2;
		Cam1.width = 2960, Cam1.height = 1924;
		Cam2.width = 2960, Cam2.height = 1924;
		Cam1.intrinsic[0] = focal, Cam1.intrinsic[1] = focal, Cam1.intrinsic[2] = 0.0, Cam1.intrinsic[3] = 1188.925, Cam1.intrinsic[4] = 979.657;
		Cam2.intrinsic[0] = focal, Cam2.intrinsic[1] = focal, Cam2.intrinsic[2] = 0.0, Cam2.intrinsic[3] = 1266.14, Cam2.intrinsic[4] = 979.657;
		Cam1.rt[0] = 0, Cam1.rt[1] = 0, Cam1.rt[2] = 0, Cam1.rt[3] = 0, Cam1.rt[4] = 0, Cam1.rt[5] = 0;
		Cam2.rt[0] = 0.05, Cam2.rt[1] = 0.0, Cam2.rt[2] = 0.0, Cam2.rt[3] = -baseline, Cam2.rt[4] = 0, Cam2.rt[5] = 0;

		GetKFromIntrinsic(Cam1.K, Cam1.intrinsic), GetiK(Cam1.invK, Cam1.K);
		GetKFromIntrinsic(Cam2.K, Cam2.intrinsic), GetiK(Cam2.invK, Cam2.K);

		GetRTFromrt(Cam1.rt, Cam1.R, Cam1.T), GetCfromT(Cam1.R, Cam1.T, Cam1.camCenter), AssembleRT(Cam1.R, Cam1.T, Cam1.RT);
		GetRTFromrt(Cam2.rt, Cam2.R, Cam2.T), GetCfromT(Cam2.R, Cam2.T, Cam2.camCenter), AssembleRT(Cam2.R, Cam2.T, Cam2.RT);

		AssembleP(Cam1.K, Cam1.RT, Cam1.P);
		AssembleP(Cam2.K, Cam2.RT, Cam2.P);

		vector<CameraData> allCalibInfo;
		allCalibInfo.push_back(Cam1), allCalibInfo.push_back(Cam2);

		ImgData imgI;
		vector<ImgData> allImgs;

		int nchannels = 1;
		imgI.color = imread("C:/temp/Pipes-perfect/im0.png", nchannels == 1 ? 0 : 1);
		imgI.width = imgI.color.cols, imgI.height = imgI.color.rows, imgI.nchannels = nchannels;
		allImgs.push_back(imgI);

		imgI.color = imread("C:/temp/Pipes-perfect/im1.png", nchannels == 1 ? 0 : 1);
		imgI.width = imgI.color.cols, imgI.height = imgI.color.rows, imgI.nchannels = nchannels;
		allImgs.push_back(imgI);

		read_pfm_file("C:/temp/Pipes-perfect/disp0.pfm", allImgs[0]);
		ConvertDisparirty2DepthMap(allImgs[0], focal, baseline, doffs);

		read_pfm_file("C:/temp/Pipes-perfect/disp1.pfm", allImgs[1]);
		ConvertDisparirty2DepthMap(allImgs[1], focal, baseline, doffs);

		DirectAlignment(allImgs, allCalibInfo);

		return 0;
	}

	vector<ImgData> allImgs;
	vector<CameraData> allCalibInfo;

	int syncId = 0;
	Corpus CorpusData;
	ReadSyncFile(Path, CorpusData, syncId);

	vector<int> camIDs; camIDs.push_back(26), camIDs.push_back(28), camIDs.push_back(30), camIDs.push_back(32), camIDs.push_back(22), camIDs.push_back(24), camIDs.push_back(20);
	for (int ii = 0; ii < camIDs.size(); ii++)
	{
		ImgData imgI;
		sprintf(Fname, "%s/Recon/urd-%03d.png", Path, camIDs[ii]);
		imgI.color = imread(Fname, 0);
		imgI.width = imgI.color.cols, imgI.height = imgI.color.rows, imgI.nchannels = 1;
		allImgs.push_back(imgI);
	}
	ReadDepthFile(Path, allImgs[0], camIDs[0]);

	for (int ii = 0; ii < camIDs.size(); ii++)
		allCalibInfo.push_back(CorpusData.camera[camIDs[ii]]);

	DirectAlignment(allImgs, allCalibInfo);

	/*for (int ii = 0; ii < camIDs.size(); ii++)
	for (int jj = 0; jj < 6; jj++)
	CorpusData.camera[camIDs[ii]].rt[jj] = allCalibInfo[ii].rt[jj];
	WriteSyncFile(Path, CorpusData, 1);*/

	return 0;
}

